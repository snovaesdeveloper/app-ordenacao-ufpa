"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[4528],{4528:(p,d,s)=>{s.r(d),s.d(d,{Questao1dPageModule:()=>l});var r=s(6895),i=s(4719),a=s(7479),n=s(7941),e=s(6738);const m=[{path:"",component:(()=>{class o{constructor(){}ngOnInit(){}}return o.\u0275fac=function(u){return new(u||o)},o.\u0275cmp=e.Xpm({type:o,selectors:[["app-questao1d"]],decls:24,vars:0,template:function(u,v){1&u&&(e.TgZ(0,"ion-header")(1,"ion-toolbar")(2,"ion-title"),e._uU(3,"questao1d"),e.qZA()()(),e.TgZ(4,"ion-content")(5,"ion-card-header")(6,"ion-card-title"),e._uU(7,"Fa\xe7a um estudo comparativo dos dois algoritmos (pivos situa\xe7\xf5es apresentadas)."),e.qZA(),e.TgZ(8,"ion-card-subtitle"),e._uU(9," Vamos realizar um estudo comparativo entre os dois algoritmos de ordena\xe7\xe3o QuickSort, um com o piv\xf4 sendo o elemento do meio e o outro com o piv\xf4 selecionado de forma aleat\xf3ria. "),e.qZA()(),e._uU(10," Desempenho com o piv\xf4 no meio: "),e.TgZ(11,"h2"),e._uU(12," Vantagens: "),e.qZA(),e._uU(13,"\nO piv\xf4 escolhido como o elemento do meio geralmente resulta em uma boa divis\xe3o do array em duas metades.\nO algoritmo pode ter um desempenho consistente em muitos casos. "),e.TgZ(14,"h2"),e._uU(15," Desvantagens:: "),e.qZA(),e._uU(16,"\nEm alguns casos, quando o array j\xe1 est\xe1 quase ordenado ou possui muitos valores repetidos, o algoritmo pode ter um desempenho inferior.\nO pior caso de desempenho ocorre quando o piv\xf4 escolhido como o elemento do meio n\xe3o divide o array igualmente.\nDesempenho com o piv\xf4 aleat\xf3rio:\n"),e.TgZ(17,"p"),e._uU(18,"\nVantagens:\nA escolha aleat\xf3ria do piv\xf4 ajuda a evitar casos de desempenho ruim causados por arrays quase ordenados ou com muitos valores repetidos.\nO algoritmo pode ter um desempenho mais equilibrado em diferentes situa\xe7\xf5es.\n"),e.qZA(),e.TgZ(19,"h2"),e._uU(20," Desvantagens: "),e.qZA(),e.TgZ(21,"p"),e._uU(22,"\nA escolha aleat\xf3ria do piv\xf4 introduz uma complexidade adicional no algoritmo.\nEm alguns casos, a escolha aleat\xf3ria pode resultar em uma divis\xe3o desigual do array.\nNo geral, ambos os algoritmos t\xeam suas vantagens e desvantagens. A escolha entre eles depende do tipo de dados que est\xe3o sendo ordenados e das caracter\xedsticas esperadas do desempenho. Em alguns casos, o algoritmo com piv\xf4 aleat\xf3rio pode ser prefer\xedvel devido \xe0 sua capacidade de lidar melhor com diferentes cen\xe1rios de dados.\n"),e.qZA(),e._uU(23,"\nPara uma an\xe1lise mais aprofundada e precisa, \xe9 recomend\xe1vel realizar testes emp\xedricos com diferentes conjuntos de dados e analisar os tempos de execu\xe7\xe3o e o comportamento do algoritmo em diferentes situa\xe7\xf5es. Isso ajudar\xe1 a determinar qual abordagem \xe9 mais adequada para cada caso espec\xedfico.\n"),e.qZA())},dependencies:[a.Zi,a.tO,a.Dq,a.W2,a.Gu,a.sr,a.wd]}),o})()}];let c=(()=>{class o{}return o.\u0275fac=function(u){return new(u||o)},o.\u0275mod=e.oAB({type:o}),o.\u0275inj=e.cJS({imports:[n.Bz.forChild(m),n.Bz]}),o})(),l=(()=>{class o{}return o.\u0275fac=function(u){return new(u||o)},o.\u0275mod=e.oAB({type:o}),o.\u0275inj=e.cJS({imports:[r.ez,i.u5,a.Pc,c]}),o})()}}]);