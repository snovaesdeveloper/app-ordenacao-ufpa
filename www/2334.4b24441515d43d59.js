"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[2334],{2334:(p,i,a)=>{a.r(i),a.d(i,{Questao1bPageModule:()=>l});var s=a(6895),d=a(4719),t=a(7479),n=a(7941),o=a(6738);const c=[{path:"",component:(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(u){return new(u||e)},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-questao1b"]],decls:12,vars:0,consts:[[2,"text-align","center"],[1,"page"]],template:function(u,E){1&u&&(o.TgZ(0,"ion-header")(1,"ion-toolbar")(2,"ion-title"),o._uU(3,"questao1b"),o.qZA()()(),o.TgZ(4,"ion-content")(5,"div")(6,"h4",0),o._uU(7," Qual e a complexidade no tempo do algoritmo? Explique. "),o.qZA()(),o.TgZ(8,"div")(9,"ion-card")(10,"div",1),o._uU(11,' A complexidade de tempo do algoritmo QuickSort \xe9 geralmente expressa como O(n log n) em m\xe9dia e O(n^2) no pior caso. Isso significa que o tempo de execu\xe7\xe3o do algoritmo cresce proporcionalmente ao tamanho da entrada, mas de forma n\xe3o linear. O QuickSort utiliza a estrat\xe9gia "dividir para conquistar", onde o array de entrada \xe9 dividido em subarrays menores, ordenados separadamente e, em seguida, combinados para obter o array ordenado completo. O piv\xf4 \xe9 escolhido e os elementos s\xe3o rearranjados em torno dele, dividindo o array em duas partes. Esse processo de divis\xe3o \xe9 realizado recursivamente at\xe9 que cada subarray contenha apenas um elemento. A complexidade de tempo O(n log n) no caso m\xe9dio ocorre quando o array \xe9 dividido em partes aproximadamente iguais em cada itera\xe7\xe3o. Nesse caso, o algoritmo \xe9 eficiente, pois a divis\xe3o equilibrada leva a um n\xfamero razo\xe1vel de compara\xe7\xf5es e trocas. No entanto, no pior caso, onde o array j\xe1 est\xe1 ordenado ou quase ordenado, o QuickSort pode ter uma complexidade de tempo de O(n^2). Isso ocorre porque o piv\xf4 escolhido n\xe3o divide o array em partes iguais, resultando em uma quantidade desequilibrada de elementos em cada subarray. Isso leva a um n\xfamero significativo de compara\xe7\xf5es e trocas, tornando o algoritmo menos eficiente. \xc9 importante mencionar que existem varia\xe7\xf5es do algoritmo QuickSort que buscam mitigar o pior caso, como a escolha do piv\xf4 de forma aleat\xf3ria ou a utiliza\xe7\xe3o de algoritmos de ordena\xe7\xe3o diferentes para subarrays pequenos. Quanto \xe0 cria\xe7\xe3o de uma p\xe1gina em Ionic justificada com margem de 20, voc\xea pode adicionar o seguinte estilo CSS \xe0 p\xe1gina em quest\xe3o: '),o.qZA()()()())},dependencies:[t.PM,t.W2,t.Gu,t.sr,t.wd],styles:[".page[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:space-between;margin:20px}"]}),e})()}];let m=(()=>{class e{}return e.\u0275fac=function(u){return new(u||e)},e.\u0275mod=o.oAB({type:e}),e.\u0275inj=o.cJS({imports:[n.Bz.forChild(c),n.Bz]}),e})(),l=(()=>{class e{}return e.\u0275fac=function(u){return new(u||e)},e.\u0275mod=o.oAB({type:e}),e.\u0275inj=o.cJS({imports:[s.ez,d.u5,t.Pc,m]}),e})()}}]);